---
title: "DGEobj: An S3 Object to Capture DGE Workflows"
author: "John Thompson"
date: "`r Sys.Date()`"
output: 
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{DGEobj Overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r global options, include = FALSE}
knitr::opts_chunk$set(echo    = TRUE, 
                      include = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      eval    = TRUE)
library(tidyverse)
library(magrittr)
library(biomaRt)
library(glue)
library(edgeR)
library(DGEobj)
library(knitr)
library(conflicted)
conflict_prefer("collapse", "glue") # inventory complains otherwise
conflict_prefer("Position", "ggplot2") # inventory complains otherwise

```


# Introduction   

The DGEobj package implements an S3 class data object, the DGEobj, that
conceptually represents an extension of the capabilities of the
RangedSummarizedExperiment (RSE) originally developed by Martin Morgan et al.
Both the DGEobj and the RSE object capture the initial data for a differential
gene expression analysis, namely a counts matrix along with associated gene and
sample annotation.  Additionally, the DGEobj extends this concept to support
capture of various downstream data objects, the intermediate steps in an
analysis, and thus capture the entire workflow of an analysis project.  

The availabilty of a collection of results in a specific structured data object
has multiple advantages.  Sharing DGE results with other colleagues is
simplified because the entire analysis is encapsulated and documented within the
DGEobj.  A recipient of data in this format can examine details of the analysis
based on the annotation built into the DGE object.  Downstream users of a
dataset can drill back to the original data or tap any intermediate data items
the original analyst captured.  Importantly,  assembling a collection of  DGE
projects in a structured format enables facile automation of integrative
multi-project metaanalyses.  

The RSE object, which motivated building the DGEobj, can capture as many assays
as desired. An "assay" is defined as any matrix with n genes (rows) and m
samples (columns). A limitation of the RSE object however is that the RSE only
allows 1 instance of row data (typically gene annotation) and 1 instance of
column data (sample annotation with one row for every column of data in the
assay slot). This limits the RSE in terms of its ability to hold downstream data
objects because many of those objects meet the definition of row data also (e.g.
DGElist, Fit objects, topTable output).  Other types of data (e.g. design
matrices, sample QC) meet the definition of column data.  Thus, the DGEobj was
modeled after the RSE object, but extended to accommodate multiple row and
column data types.  The DGEobj is thus uniquely suited to capturing the entire
workflow of a DGE analysis.  

# DGEobj Structure  

## Base Types  

The DGEobj supports four distinct data types, that we refer to as "base types":   

* assay data: dataframes or matrices of data with n rows (genes or transcripts)
and m columns (samples)  
* rowData: a dataframe with n rows typically containing information about each
gene with as many columns as needed (gene ID, gene symbols, chromosome
information, etc).  Other types of rowData include the edgeR DGElist object,
design matrices, and Fit objects  
* colData: a dataframe with m rows, that is, one row for each sample column in
the assay slot  
* metaData: anything that doesn't fit in one of the other slots  

Fundamentally, the base type defines how an item should be subsetted (see the
section on subsetting below).

## DGEobj Nomenclature: Items, Types and Base Types  

Multiple instances of a base type are accommodated by defining data "types" and
"items".  Each data type is assigned a base type (e.g. geneData, GRanges, and
Fit objects are all "types" of "baseType" = rowData).  

You can generally have multiple instances of each type (exceptions described in
Unique Items section).  Each instance of a "type" is described as an "item" and
each item must have an user-defined item name.  The item name must be unique
within a DGEobj.  

## Unique Items  

The design goal of the DGEobj is that it should capture the workflow and
analysis results of a single dataset.  As such, certain items that constitute
the "raw" or starting point data are assigned a "unique" attribute that limits
such "types" to one instance per DGEobj.  

Three items: counts, design (sample information), and geneData (or isoformData,
or exonData) are defined as unique.  If complete chromosome location data (Chr,
Start, End, Strand) are supplied in the geneData item, then a GRanges item is
also created upon initializing a DGEobj.  

## Levels   

Several levels are predefined for DGEobj objects to accomodate RNA and proteomic
applications (allowedLevels = c("gene", "isoform", "exon", "proteingroup",
"peptide", "ptm", "protein")).  A DGEobj may contain only one of these levels.
Thus a user would need to create separate DGEobjs for gene and isoform level
data in an RNA transcription analysis mode.  Gene level data will be used Within
this vignette.  

## Parentage  

An analysis can become multi-threaded.  For example, multiple models can be fit
with one dataset.  Two features of the DGEobj serve to manage multi-threaded
analyses.  First, the starting data are unique.  Thus all threads map back to the
starting data.  Only one instance of the starting data types are allowed.  For
the RNA-Seq application, Unique types are the "counts", "design" (sample data),
and "geneData".  Secondly, parent/child relationships are captured.  Each data
item carries a parent attribute that holds the item name of the parent data item.  In
this way, for example, a topTable item can be linked to the contrast fit that
produced it.  

## Original Data  

In the course of a workflow an analyst will often need to subset the DGEobj
based on low signal or other characteristics.   However, a downstream analyst
may need to start their analysis with the original unsubsetted data.  For this
reason, when the DGEobj is initialized, a copy of the starting data is also
stored in a metadata slot.  Metadata slots are carried along without subsetting
so the original data may always be retrieved from these metadata items.  The
item names of the original data in the metadata slot have a "_orig" suffix.  


## Demonstration Dataset: Rat Liver Slice Compound Treatments  

The following dataset was selected to demonstrate building and working with the
DGEobj data structure.  

Huang X, Cai H, Ammar R, Zhang Y et al. Molecular characterization of a
precision-cut rat liver slice model for the evaluation of antifibrotic
compounds. Am J Physiol Gastrointest Liver Physiol 2019 Jan 1;316(1):G15-G24.
PMID: 30406699  

Briefly, livers were removed from rats 4 weekds after bile duct ligation or sham
operation.  Rat liver slices were incubated in vitro with potential
anti-fibrotic compounds.  At the end of the incubation whole transcriptome
RNA-Seq analysis was performed.  

Files containing counts and sample annotations associated with this project will
be downloaded from the NCBI GEO resource
(https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804).  

The GEO data includes Ensembl gene ids.  Additional gene information such as
chromosome positions, type of transcript, etc, will be downloaded from Ensembl
using the biomaRt package.  

# Working with DGE objects  

You can create a DGEobj from a set of data frames containing the counts,
geneData, and design information (sample annotation).  

## Initializing a DGEobj from dataframes  

Three properly formatted data frames are required to initialize a new DGEobj.  

1. Counts matrix:  For RNA-Seq, this is typically a genes x samples matrix of
numbers.  Rownames must be present and contain a unique identifier (e.g. Ensembl
geneid).  Colnames should be a unique sample identifier. You will also need to
specify the "level" of your data (allowedLevels = c("gene", "isoform", "exon",
"proteingroup", "peptide", "ptm", "protein")).  

2. Row Data:  Additional annotations for the entities represented by each row.
For the RNA-Seq case, this dataframe holds associated gene annotation.  The
rownames in the RowData must match the rownames in the counts matrix.  

3. Col Data: Accordingly the ColData dataframe contains information about the
samples (columns) of the counts matrix.  We often refer to this as the "design"
table because it typically contains the experimental details of the treatment of
each sample.  The rownames of ColData must match the colnames of the Counts
Matrix.  

### Retrieve GEO data for GSE120804

This GEO project includes a counts table and design table in the supplemental
section. The data is downloaded to temp files and imported into data frames to
prepare for building a DGEobj.  


```{r downloadGEOData}

# Get the raw counts and sample annotation ("design") from GEO
# Source: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804
getLocation <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE120nnn/GSE120804/suppl"
countsFile <- "GSE120804_counts.txt.gz"
designFile <- "GSE120804_geo_sample_annotation_edit.csv.gz"
counts_url <- glue("{getLocation}/{countsFile}")
design_url <- glue("{getLocation}/{designFile}")

temp <- tempfile()
if (download.file(counts_url, destfile = temp, mode = 'wb') > 0) stop ("Counts Download Failed")
counts <- read.delim(temp, stringsAsFactors = FALSE, row.names = 1)
unlink(temp)

temp <- tempfile()
if (download.file(design_url, destfile = temp, mode = 'wb')) stop ("Design Download Failed")
design <- read.csv(temp, stringsAsFactors = FALSE)
unlink(temp)

```

### Edit/Parse the Design Table  

Often the design table will need some manipulation to construct the columns
required to support a planned analysis.  Although the design data can be edited
directly within a DGEobj,  it is recommended to restructure the design table as
needed at the onset of the analysis.  

In this example, the design file as downloaded does NOT have a column that
matches the colnames column of the counts file. However, the colnames from
counts are present as a substring within the fastq filename column
(design$raw.file).  The samplenames will be parsed from the fastq filenames to
create a proper linking column between the counts and design data.  

```{r parseDesignSampleNames}

rownames(design) <- str_sub(design$raw.file, start = 1, end = 21)

```

Additional manipulations to the design data include:  
* renaming a column   
* create a design$DiseaseStatus column to indicate whether a liver is derived
from a BDL or sham animal.  
* create an animal number column to capture which liver slice samples were
derived from the same animal.  

```{r moreDesignEdits}

#correct the desired case/spelling of one column
design %<>% dplyr::rename(ReplicateGroup = Replicate.group)

# Create a DiseaseStatus column by parsing ReplicateGroup
design$DiseaseStatus <- rep("Sham", nrow(design))
idx <- str_detect(design$ReplicateGroup, "BDL")
design$DiseaseStatus[idx] <- "BDL"

# Create an animal# column.  The animal number is encoded in the sample.name
# column.
design$AnimalNum <- str_match(design$Sample.name, "r[0-9]{1,3}")

```

## Retrieve Gene Annotation from Ensembl   

The GEO data for this project only supplied Ensembl gene IDs.  Additional gene
information will be collected by querying Ensembl directly.  

```{r getGeneAnnotation}

# Now let's get the gene annotation from Ensembl/biomaRt
ens.ds      <- "rnorvegicus_gene_ensembl"
ens.mart    <- useMart(biomart = "ensembl", dataset = ens.ds)
ens.columns <- c("ensembl_gene_id", "rgd_symbol", "chromosome_name", "start_position",
                 "end_position", "strand", "gene_biotype", "description")
ens.data    <- getBM(attributes = ens.columns, values = rownames(counts), mart = ens.mart) %>%
    distinct(ensembl_gene_id, .keep_all = T)

# Filter the list to the genes used in the test dataset and properly format gene
# information for GenomicRanges use
gene.data <- left_join(data.frame(ensembl_gene_id = rownames(counts), stringsAsFactors = F),
                       ens.data,
                       by = "ensembl_gene_id") %>%
    dplyr::rename(start = start_position, end = end_position) %>%
    mutate(strand = case_when(strand == -1 ~ "-",
                              strand == 1  ~ "+",
                              TRUE         ~ "*"))
rownames(gene.data) <- gene.data$ensembl_gene_id

```

## Validate Dataframe Relationships

As mentioned earlier, rownames and column names provide links between the three
starting data frames.  

* The rownames in the gene annotation must match the rownames in the counts
matrix.  
* The rownames of the design table must match the colnames of the counts matrix.  

These statements perform a reality check on these two constraints.  

```{r realityCheck}

all(rownames(counts) == rownames(gene.data))
all(colnames(counts) == rownames(design))

```

## Instantiate the DGEobj  

With the above constraints met, the three data frames can be used to instantiate
a DGEobj.  In addition the "level" of the data must be specified in the "level"
argument (Allowed levels include "gene", "isoform", "exon", "proteingroup",
"peptide", "ptm", or "protein").  Finally, two attributes are added via the
customAttr argument to annotate the genome and gene model set used for the
alignments used to produce the count data.    

```{r initializeDGEobj}

dgeObj <- DGEobj::initDGEobj(counts  = counts,
                       rowData = gene.data,
                       colData = design,
                       level = "gene",
                       customAttr = list(Genome    = "Rat.B6.0",
                                         GeneModel = "Ensembl.R89"))
```

Although it is possible to add many or all project attributes with the customAttr
argument, this can also be tedious when many more attributes are desired.  A
more convenient way to add project attributes to the DGEobj is provided using
the annotateDGEobj function.  This function reads key/value pairs from a text
file.  Thus a text file template can be provided to less technical collaborators
to capture important experiment metadata.   

The annotation file for this project looks like this:  

```
# Some basic metadata about the project
level=gene
source=https://github.com/cb4ds/DGEobj/blob/master/vignettes/DGEobj_Overview.Rmd
ID=BDL_Rat_LiverSlice_03Dec2017
BMS_PID=P-20170808-0001
Title=Rat Liver Slices from Bile Duct Ligation animals
Organism=Rat
GeneModel=Ensembl.R89
PlatformType=RNA-Seq
Description=Rat livers slices from sham or BDL +/- efficacious treatments incubated in vitro
Keywords=Liver slices; Bile Duct Ligation
Disease=Liver Fibrosis
Tissue=Liver
GEO=GSE120804

# additional descriptive attributes 

Technology=Illumina-HiSeq
LibraryPrep=TruSeq Stranded Total RNA 
AlignmentReference=Rat.B6.0
ReadType=PE
Pipeline=RNA-Seq_BMS_v2.4.pscript
AlignmentAlgorithm=OSA
ScriptID=RNA-Seq_BMS_v2.4.pscript

# Institutional attributes

BusinessUnit=Discovery
FunctionalArea=Fibrosis
Vendor=BMS
TBio_Owner=Ron Ammar
TA_Owner=John Huang
```


```{r annotateFromTextFile}
annotationFile <- system.file("GSE120804_ProjectAttributes.txt", package = "DGEobj", mustWork = TRUE)

dgeObj <- annotateDGEobj(dgeObj, annotationFile)

```

The DGE object now contains the starting data  and metadata and is analysis-ready.  

To view a listing of the items in the DGEobj:  

```{r inventory}

kable(inventory(dgeObj))

```

To list the meta data associated with a project:    

```{r showMetaData}

kable(showMeta(dgeObj))


# Test Solution to wrap the text in the second column???
kable(showMeta(dgeObj), "latex") %>%
  kableExtra::column_spec(2, width = "3in")

```

## DGEobj Length and Dimensions  

The length of a DGEobj refers to the number of data items in the DGEobj.   

```{r length}
length(dgeObj)
```

The dimensions reported for a DGEobj are the dimensions of the assays contained
in the DGEobj.  That is, for the RNA-Seq application, the row dimension is the
number of genes contained in the object and the column dimension is the number
of samples contained in the object.  

```{r dimensions}
dim(dgeObj)
dim(dgeObj$counts)
```

## Rownames and Colnames  

The rownames and colnames of the DGEobj are defined by the first "assay" matrix
in a DGEobj, typically the counts matrix for RNA-Seq data.  

Note, there is no facility provided to re-assign rownames or colnames of a DGEobj.
This is because it cannot be guaranteed that an object stored in the DGEobj has
row/colname assignment support.  

## Subsetting a DGEobj  

A DGEobj may be square bracket subsetted similar to the way data frames and
matrices may be subsetted.  The subsetting function uses the base type to define
how each data item is handled during subsetting. Metadata items are carried
along unchanged.  

```{r subsetting}

#subset to the first 100 genes
First100genes <- dgeObj[1:100,]
dim(First100genes)

#subset to the first 10 samples
First10samples <- dgeObj[,1:10]
dim(First10samples)

#susbet genes and samples
AnotherSubset <- dgeObj[1:100, 1:10]
dim(AnotherSubset)

```

You may also use boolean vectors to subset dimensions of a DGEobj.  

```{r booleanIndexing}
# select a subset of samples
idx <- dgeObj$design$DiseaseStatus == "BDL"
BDLonly <- dgeObj[,idx]
dim(BDLonly)
```

## Inventory of a DGEobj  

The `inventory()` function prints a table of the data items present in a DGEobj.  The output includes the item name, type, baseType, parent, class, and date created.  If the `verbose = TRUE` argument is used, a `funArgs` column is also included.  

```{r inventory2}
inventory(dgeObj)
```

If you just need the item names of data stored in the DGEobj, use the base `names()` function.  

```{r itemNames}
names(dgeObj)
```

## Adding Items to a DGEobj

As an analysis progresses, the data analyst should capture intermediate data
objects deemed important to properly documenting the workflow.  In the example
here, a the counts will be normalized and the resulting DGElist data item added
to the DGEobj.  


```{r addItem}
# Perform TMM normalization on the raw counts
dgelist <- dgeObj$counts %>%
  DGEList() %>%
  calcNormFactors(method = "TMM")

# add the resulting edgeR DGEList item to the DGEobj
newdgeObj <- addItem(dgeObj, 
                    item     = dgelist,
                    itemName = "normTMM",
                    itemType = "DGEList",
                    parent   = "counts",
                    funArgs  = "calcNormFactors; TMM"
)

kable(inventory(newdgeObj))
```

The item is the actual data object to add.   

The itemName is the user-defined name for that object.   

The itemType is the predefined type.  To see a list of pre-defined types use the
function **showTypes(dgeObj)**.  

The value of parent argument is analyst-defined and is particularly important
for a multi-threaded analysis.  For example, if more than one fit is applied to
the data, the parent argument maintains the thread and unambiguously identify
the child objects of each branch in the workflow.  The value assigned to parent
should be the item name of the parent data object.  

By default `addItem()` will refuse to add an `itemname` that already exists.
There is an overwrite argument to the `addItem()` function although its use is
discouraged.   Use the `overwrite = TRUE` argument if it is neccesary to make a
posthoc change to an item that already exists in the DGEobj.   

### Automating funArgs entries

If a whole analysis step, together with the addItem call, is contained within a
function, it becomes easy to automate capture of function arguments.  

Within a function call,  `match.call()` returns the calling function name and
arguments.   Modifying the normalization example above:  

```{r addItemFunctionalized}

runNorm <- function(x, method){
  # Perform TMM normalization on the raw counts
  dgelist <- x$counts %>%
    DGEList() %>%
    calcNormFactors(method = method)
  
  # add the resulting edgeR DGEList item to the DGEobj
  x <- addItem(x, 
               item     = dgelist,
               itemName = "normTMM",
               itemType = "DGEList",
               parent   = "counts",
               funArgs  = match.call()
  )
}

newdgeObj <- runNorm(dgeObj, method="TMM")

```



### Batch addition of multiple items  

The addItem function is useful to capture each item during the course of an
analysis.  Another use case is constructing a DGEobj in a posthoc fashion.  In
this senario, it may be more effcient to collect and add multiple items and the
addItems option support this senario.

In this example, add a normalized dgelist and a design matrix to the DGEobj:  

```

MyDgeObj <- addItems(MyDgeObj, 
                     itemList  = MyItems,
                     itemTypes = MyTypes,
                     parents   = MyParents,
                     itemAttr  = MyAttributes)
```

`itemList` is a list of the data objects to add.

`itemTypes` is a list of the types for each item in `itemList`.  

`parents` is a list of the parent item names for each item in `itemList`. 

`itemAttr` is an optional named list of attributes that will be added to every item on the `itemList`.  Note that the DGEobj has attributes and each item within the DGEobj can have its own attributes.  Here the attributes are being added to the individual items.



## Adding a new data type

A set of data types has already been defined based on data types I encounter in my typical edgeR/Voom workflow.  Certainly, I haven't thought of everything that someone might want to capture.  Therefore, new types can be defined on the fly.

```
# See predefined data types
showTypes(MyDgeObj)

# Add a new colData datatype called "sampleQC"
MyDgeObj <- newType(MyDgeObj,
                    itemType = "sampleQC",
                    baseType = "col",
                    uniqueItem = FALSE)

```

## Accessing data in a DGEobj

You'll likely need to access various components of the DGEobj as you progress through you work flow.  There are several ways to extract one or more components from the DGEobj for use in your analysis.

### Retrieve a single item

The `getItem()` function allows you to retrieve any item in a DGEobj by referencing its name. Use the inventory function (described above) to check the contents of the DGEobj.

```
MyCounts <- getItem(MyDgeObj, "counts")
```

### Retrieve multiple items

There are several ways to retrieve multiple items as a list or data objects.

You can supply a list of item names to retrieve specific items.  The items requested are returned in a list.  

```
MyItems <- getItems(MyDgeObj, list("counts", "geneData"))
```

If all the items you wish to retrieve are of the same type, you can use the `getType()` function to retrieve them as a list.  For example, you might want to retrieve a set of contrast results present as topTable output.  

```
MyContrasts <- getType(MyDgeObj, "topTable")
```

Similarly, you can retrieve all items of the same baseType as a list.

```
MyRowData <- getBaseType(MyDgeObj, "row")
```

Finally, should you need to retrieve all the items in a DGEobj as a simple list, you can recast the DGEobj as a simple list.

```
MyList <- as.list(MyDgeObj)
```

## Ancillary Functions  

### Function showTypes()

Shows all the pre-defined types in a DGEobj.  This shows all types, whether or not the DGEobj contains data associated with a given type.

```
showTypes(MyDgeObj)
```

### Function baseType()

Returns the baseType for a given Type

```
baseType(MyDgeObj, "DGEList")
```

### Function getAttribute() and getAttributes()

These are for retrieving attributes from an individual item.  So far, the only place where I've used attributes attached to an item (as opposed to the DGEobj itself) is the design matrix.  In my work flow I attach the formula as an attribute of the design matrix.

```
getAttribute(MyDgeObj$designMatrix, "formula")
```

If an item had multiple attributes, you could retrieve the list of attributes with `getAttributes()`.  `getAttributes()` by default excludes common attributes including dim and dimnames which already have base functions for accessing.

### Function getItemAttributes()

This function will retrieve a requested attribute from all items in a DGEobj, returned as a list.

```
getItemAttribute(MyDgeObj, "attributeName")
```

### Function rmItem()

For the most part, you'll be collecting and adding new objects to a DGEobj in the course of an analysis.  The `rmItem()` function is added for the case  where you might need to delete a particular item.  

To delete an item from a DGEobj:

```
MyDgeObj <- rmItem(MyDgeObj, "itemName")
```

### Function setAttributes()

You can add attributes to an item with the `addItem()` function.  This function provides an alternate mechanism to add attributes to an item which would typically be done before adding the item to a DGEobj.

```
MyItem <- setAttributes(MyItem, list(date=date(), analyst="JRT"))
```

### Function showMeta()

This function is intended to return any project oriented attributes assigned to the DGEobj using function `annotateDGEobj()`.  It returns the attributes as a two column dataframe of Attribute/Value pairs.

```
MyAnnotation <- showMeta(MyDgeObj)
```


